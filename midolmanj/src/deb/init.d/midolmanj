#! /bin/sh

# Copyright 2011 Midokura KK

### BEGIN INIT INFO
# Provides:             midolmanj
# Required-Start:       $remote_fs $syslog
# Required-Stop:        $remote_fs $syslog
# Default-Start:        2 3 4 5
# Default-Stop:         0 1 6
# Short-Description:    Midokura MidolmanJ server
### END INIT INFO

# Do NOT "set -e"

# /etc/init.d/midolmanj: start and stop the MidolmanJ daemon

MIDO_HOME=/usr/share/midolman
MIDO_ETC=/etc/midolman
MIDO_MAIN=com.midokura.midolman.Midolman
# FIXME(tfukushima): Remove hard coded version number.
MIDO_JAR=$MIDO_HOME/midolmanj.jar
MIDO_BOOTSTRAP_JAR=$MIDO_HOME/midokura-jdk-bootstrap.jar
MIDO_CFG=$MIDO_ETC/midolman.conf
MIDO_LOG_DIR=/var/log/midolman/
QUAGGA_DIR=/var/run/quagga/
MIDO_DEBUG_PORT=8001
MIDO_DEP_CLASS_PATH=`echo $MIDO_HOME/dep/* | sed 's/ /:/g'`

# OpenJDK uses the system jnidispatcher as default, since /usr/lib/jni is in the
# java library path. We specify our jna.jar in the classpath, this leads to incompatibility.
# We should use either (1) the system jnidispatcher and the system jna.jar
# or (2) the packaged jnidispatcher and the packaged jna.jar.
# Here we remove the /usr/lib/jni from the library path to use the package
# jnidispatcher
JAVA_LIBRARY_PATH=-Djava.library.path=/lib:/usr/lib

# Exit if the package is not installed
# Test that midolmanj is installed
[ -r $MIDO_JAR ] || exit 0
# Test that midolmanj installed and not purged
[ -r $MIDO_CFG ] || exit 0
umask 022
. $MIDO_ETC/midolman-env.sh

#add log dir java env variable
JAVA_OPTS="$JVM_OPTS -Dmidolman.log.dir=$MIDO_LOG_DIR"

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/sbin:/usr/sbin:/bin:/usr/bin
DESC="Midolman: OVS kmod-based network controller"
SCRIPTNAME=/etc/init.d/$NAME

# Read configuration variable file if it is present
[ -r /etc/default/$NAME ] && . /etc/default/$NAME

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions

is_running()
{
    start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $JAVA \
        --test > /dev/null \
                || return 1
    return 0
}

#
# Function that starts the daemon/service
#
do_start()
{
    # Return
    #   0 if daemon has been started
    #   1 if daemon was already running
    #   2 if daemon could not be started
    if [ ! -d /sys/module/openvswitch ] && [ ! -d /sys/module/openvswitch_mod ]; then
        echo "Loading openvswitch kernel module"
        modprobe openvswitch_mod 2>/dev/null || modprobe openvswitch || return 2
    fi

    echo -n "Starting midolmanj... "

    is_running || return 1

    if [ ! -d $PIDDIR ]
    then
        mkdir -p $PIDDIR
    fi
    chown $USER:$GROUP $PIDDIR

    if [ ! -d  $MIDO_LOG_DIR ]
    then
        mkdir -p $MIDO_LOG_DIR
    fi
    chown $USER:$GROUP $MIDO_LOG_DIR

    # allow midolman to write to /var/run/quagga
    if [ ! -d $QUAGGA_DIR ]; then
        mkdir -p -m 755 $QUAGGA_DIR
        chown quagga:quagga $QUAGGA_DIR
    fi
    chmod g+w $QUAGGA_DIR

    start-stop-daemon --start --quiet \
               --pidfile $PIDFILE \
               --make-pidfile \
               --background \
               --exec $JAVA -- \
                   $JAVA_LIBRARY_PATH \
                   -Xbootclasspath/p:$MIDO_BOOTSTRAP_JAR \
                   -cp $MIDO_ETC:$MIDO_JAR:$MIDO_DEP_CLASS_PATH \
                   $JAVA_OPTS \
                   $MIDO_MAIN \
                   -c $MIDO_CFG \
        || return 2
    echo "done"
}

#
# Function that stops the daemon/service
#
do_stop()
{
    echo -n "Stopping midolmanj... "
    # Return
    #   0 if daemon has been stopped
    #   1 if daemon was already stopped
    #   2 if daemon could not be stopped
    #   other if a failure occurred
    is_running && return 1

    start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $PIDFILE

    echo "done"
    RETVAL="$?"
    [ "$RETVAL" = 2 ] && return 2
    # Many daemons don't delete their pidfiles when they exit.
    [ "$RETVAL" = 0 ] && rm -f $PIDFILE
    return "$RETVAL"
}

case "$1" in
    start)
        if [ "x$JMXDISABLE" = "x" ] ; then
            [ "$VERBOSE" != no ] && log_action_msg "$NAME: JMX enabled by default"
        else
            [ "$VERBOSE" != no ] && log_action_msg "$NAME: JMX disabled by user request"
        fi

        [ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "$NAME"
        do_start
        case "$?" in
            0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
            2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
        esac
        ;;
    start-debug)
        JAVA_OPTS="$JAVA_OPTS -Xdebug -Xrunjdwp:transport=dt_socket,address=$MIDO_DEBUG_PORT,server=y,suspend=y"
        do_start
        ;;
    stop)
        [ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
        do_stop
        case "$?" in
            0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
            2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
        esac
        ;;
    status)
       status_of_proc -p $PIDFILE "$NAME" "$NAME" && exit 0 || exit $?
       ;;
    restart|force-reload)
        #
        # If the "reload" option is implemented then remove the
        # 'force-reload' alias
        #
        log_daemon_msg "Restarting $DESC" "$NAME"
        do_stop
        case "$?" in
            0|1)
                do_start
                case "$?" in
                    0) log_end_msg 0 ;;
                    1) log_end_msg 1 ;; # Old process is still running
                    *) log_end_msg 1 ;; # Failed to start
                esac
                ;;
            *)
                # Failed to stop
                log_end_msg 1
                ;;
        esac
        ;;
    *)
        echo "Usage: $SCRIPTNAME {start|stop|status|restart|force-reload|start-debug}" >&2
        exit 3
        ;;
esac

